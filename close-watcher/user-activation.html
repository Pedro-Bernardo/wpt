<!doctype html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="/resources/testdriver-actions.js"></script>

<div id="d" style="height: 100px; width: 100px;"></div>
<script>
// TODO(domenic): consider moving these helpers into a separate file and using them in other tests too.
function createRecordingCloseWatcher(t, events, name) {
  const watcher = new CloseWatcher();
  t.add_cleanup(() => watcher.destroy());
  watcher.oncancel = () => events.push(name + " cancel");
  watcher.onclose = () => events.push(name + " close");

  return watcher;
}

function createBlessedRecordingCloseWatcher(t, events, name) {
  return test_driver.bless("create " + name, () => createRecordingCloseWatcher(t, events, name));
}

function sendCloseSignal() {
  // *not* \uu001B; see https://w3c.github.io/webdriver/#keyboard-actions
  const ESC = '\uE00C';

  return test_driver.send_keys(document.getElementById("d"), ESC);
}

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");

  await test_driver.bless("call close()", () => freeWatcher.close());

  assert_array_equals(events, ["freeWatcher cancel", "freeWatcher close"]);
}, "CloseWatchers created without user activation, but close()d via user activation, fires cancel");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");
  freeWatcher.addEventListener("cancel", e => e.preventDefault());

  await test_driver.bless("call close()", () => freeWatcher.close());

  assert_array_equals(events, ["freeWatcher cancel"]);
}, "CloseWatchers created without user activation, but close()d via user activation, fires cancel, which can be preventDefault()ed");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");

  await test_driver.bless("send close signal", () => sendCloseSignal());

  assert_array_equals(events, ["freeWatcher cancel", "freeWatcher close"]);
}, "CloseWatchers created without user activation, but closed via a close signal after via user activation, fires cancel");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");
  freeWatcher.addEventListener("cancel", e => e.preventDefault());

  await test_driver.bless("send close signal", () => sendCloseSignal());

  assert_array_equals(events, ["freeWatcher cancel"]);
}, "CloseWatchers created without user activation, but closed via a close signal after via user activation, fires cancel, which can be preventDefault()ed");

promise_test(async t => {
  const events = [];
  createRecordingCloseWatcher(t, events, "freeWatcher");
  createRecordingCloseWatcher(t, events, "watcher1");
  createRecordingCloseWatcher(t, events, "watcher2");

  await sendCloseSignal();
  assert_array_equals(events, ["watcher2 close", "watcher1 close"]);
}, "Multiple CloseWatchers created without user activation close together (with no cancel)");

promise_test(async t => {
  const events = [];
  createRecordingCloseWatcher(t, events, "freeWatcher");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher");

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher close", "freeWatcher close"]);
}, "Creating a CloseWatcher from user activation keeps it separate from the free CloseWatcher, but they don't fire cancel");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");
  const activationWatcher = await createBlessedRecordingCloseWatcher(t, events, "activationWatcher");

  await test_driver.bless("call activationWatcher.close()", () => activationWatcher.close());
  assert_array_equals(events, ["activationWatcher cancel", "activationWatcher close"]);

  await test_driver.bless("call activationWatcher.close()", () => freeWatcher.close());
  assert_array_equals(events, ["activationWatcher cancel", "activationWatcher close", "freeWatcher cancel", "freeWatcher close"]);
}, "Creating a CloseWatcher from user activation, and close()ing CloseWatchers with user activation, fires cancel");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");
  const activationWatcher = await createBlessedRecordingCloseWatcher(t, events, "activationWatcher");

  await test_driver.bless("call activationWatcher.close()", () => sendCloseSignal());
  assert_array_equals(events, ["activationWatcher cancel", "activationWatcher close"]);

  await test_driver.bless("call activationWatcher.close()", () => sendCloseSignal());
  assert_array_equals(events, ["activationWatcher cancel", "activationWatcher close", "freeWatcher cancel", "freeWatcher close"]);
}, "Creating a CloseWatcher from user activation, and closing CloseWatchers with a close signal after user activation, fires cancel");

promise_test(async t => {
  const events = [];
  createRecordingCloseWatcher(t, events, "freeWatcher");

  await test_driver.bless("create two more CloseWatchers", () => {
    createRecordingCloseWatcher(t, events, "activationWatcher1");
    createRecordingCloseWatcher(t, events, "activationWatcher2");
  });

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher2 close", "activationWatcher1 close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher2 close", "activationWatcher1 close", "freeWatcher close"]);
}, "Multiple CloseWatchers created from a single user activation close together, but original free CloseWatcher closes separately");

promise_test(async t => {
  const events = [];
  createRecordingCloseWatcher(t, events, "freeWatcher");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher1");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher2");

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher2 close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["activationWatcher2 close", "activationWatcher1 close"]);
}, "Multiple CloseWatchers created with user activation close in reverse order");

promise_test(async t => {
  const events = [];
  createRecordingCloseWatcher(t, events, "freeWatcher");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher1");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher2");
  await createBlessedRecordingCloseWatcher(t, events, "activationWatcher3");
  createRecordingCloseWatcher(t, events, "watcher4");

  await sendCloseSignal();
  assert_array_equals(events, ["watcher4 close", "activationWatcher3 close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["watcher4 close", "activationWatcher3 close", "activationWatcher2 close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["watcher4 close", "activationWatcher3 close", "activationWatcher2 close", "activationWatcher1 close"]);

  await sendCloseSignal();
  assert_array_equals(events, ["watcher4 close", "activationWatcher3 close", "activationWatcher2 close", "activationWatcher1 close", "freeWatcher close"]);
}, "3 user activations let you have 3 + 1 = 4 ungrouped close watchers/0 cancel events");

promise_test(async t => {
  const events = [];
  const freeWatcher = createRecordingCloseWatcher(t, events, "freeWatcher");
  const activationWatcher1 = await createBlessedRecordingCloseWatcher(t, events, "activationWatcher1");
  activationWatcher1.addEventListener("cancel", e => e.preventDefault());

  await test_driver.bless("close() activationWatcher1", () => {
    activationWatcher1.close();
  });
  assert_array_equals(events, ["activationWatcher1 cancel"]);

  // This time we go straight to close, without a second cancel.
  activationWatcher1.close();
  assert_array_equals(events, ["activationWatcher1 cancel", "activationWatcher1 close"]);

  freeWatcher.close();
  assert_array_equals(events, ["activationWatcher1 cancel", "activationWatcher1 close", "freeWatcher close"]);
}, "3 user activations let you have 2 close watchers with 1 cancel event, even if the first cancel event is prevented");

promise_test(async t => {
  const events = [];
  const freeWatcher1 = createRecordingCloseWatcher(t, events, "freeWatcher1");

  freeWatcher1.destroy();
  assert_array_equals(events, []);

  const freeWatcher2 = createRecordingCloseWatcher(t, events, "freeWatcher2");

  await sendCloseSignal();
  assert_array_equals(events, ["freeWatcher2 close"]);
}, "destroy()ing the free CloseWatcher allows a new free one to be created without user activation, and it receives the close signal");

promise_test(async t => {
  const events = [];
  const freeWatcher1 = createRecordingCloseWatcher(t, events, "freeWatcher1");

  freeWatcher1.close();
  assert_array_equals(events, ["freeWatcher1 close"]);

  const freeWatcher2 = createRecordingCloseWatcher(t, events, "freeWatcher2");

  await sendCloseSignal();
  assert_array_equals(events, ["freeWatcher1 close", "freeWatcher2 close"]);
}, "close()ing the free CloseWatcher allows a new free one to be created without user activation, and it receives the close signal");

promise_test(async t => {
  const events = [];
  const freeWatcher1 = createRecordingCloseWatcher(t, events, "freeWatcher1");

  await sendCloseSignal();
  assert_array_equals(events, ["freeWatcher1 close"]);

  const freeWatcher2 = createRecordingCloseWatcher(t, events, "freeWatcher2");

  await sendCloseSignal();
  assert_array_equals(events, ["freeWatcher1 close", "freeWatcher2 close"]);
}, "closing the free CloseWatcher via a close signal allows a new free one to be created without user activation, and it receives a second close signal");
</script>
